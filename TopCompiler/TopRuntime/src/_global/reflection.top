type ext IntType =
    sign: bool
    size: uint

def IntType.toString(&self) string =
    if self.sign then "i{self.size * 8}"
    else "u{self.size * 8}"

type ext FloatType =
    size: uint

def FloatType.toString(&self) string =
    "f{self.size*8}"

type ext BoolType =

def BoolType.toString(&self) string =
    "bool"

type ext StringType =

def StringType.toString(&self) string =
    "string"

type AliasType =
    name: string
    package: string
    real_type: Type

def AliasType.toString(&self) string =
    "{self.package}.{self.name}"

type PointerType =
    p_type: Type

def PointerType.toString(&self) string =
    "&{self.p_type}"

type StructType =
    name: string
    package: string
    real_type: Type
    fields: []Field
    size: SizeT

def StructType.toString(&self) string =
    if self.package == "_global" then self.name
    else "{self.package}.{self.name}"

type Cases =
    name: string
    args: []Type

type Field =
    name: string
    offset: uint
    field_type: Type

type Method =
    name: string
    pointer_to_method: &none

type EnumType =
    name: string
    package: string
    cases: []Cases
    methods: []Method

def EnumType.toString(&self) string =
    "{self.package}.{self.name}"

type FuncType =
    args: []Type
    return_type: Type

type InterfaceType =
    name: string
    package: string
    fields: []Field
    methods: &[]Method

def InterfaceType.toString(&self) string =
    "{self.package}.{self.name}"

type ArraySize either
    Static(uint)
    Dynamic
    Both

type ArrayType =
    size: ArraySize
    array_type: Type

def ArrayType.toString(&self) string =
    match self.size with
        Static length -> "[{length}]{self.array_type}"
        Dynamic -> "[..]{self.array_type}"
        Both -> "[]{self.array_type}"

type CharType =

type ext NoneType =
def NoneType.toString(&self) string =
    "none"

type Type with
    def toString() string
    //def get_method(string) Maybe[&Method]
    //def get_field(string) Maybe[&Field]
