type SizeT is uint

ext _ = '#include <string.h>'
ext memcpy: |&none, &none, SizeT| -> none = 'memcpy'
ext c_alloc: |SizeT| -> &none = 'malloc'
ext c_free: |&none| -> none = 'free'

type Allocator with
    def get_occupied() uint
    def alloc(SizeT) &none
    def dealloc(&none)
    def reset_to(uint)
    def free_allocator()

temporary_storage := new_TemporaryStorage 100_000
longterm_storage_allocator := new_TemporaryStorage 100_000_000
malloc := Malloc{}

temporary_storage_as_allocator := &temporary_storage as Allocator
malloc_as_allocator := &malloc as Allocator
longterm_storage_as_allocator := &longterm_storage_allocator as Allocator

#addToContext allocator := &temporary_storage_as_allocator
#addToContext longterm_storage := &longterm_storage_as_allocator

type TemporaryStorage =
    occupied: SizeT
    highest: SizeT
    data: &none
    maxSize: SizeT

def new_TemporaryStorage(maxSize: SizeT) TemporaryStorage =
    TemporaryStorage{
        occupied = 0
        highest = 0
        data = c_alloc maxSize
        maxSize = maxSize
    }

def TemporaryStorage.get_occupied(&self) uint =
    self.occupied

def TemporaryStorage.alloc(&self, size: SizeT) &none =
    occupied := self.occupied
    self.occupied += size

    if self.occupied > self.highest then
        self.highest = self.occupied

    if self.occupied >= self.maxSize then
        context.allocator = context.longterm_storage

        log "ERROR: used more tempory memory than available: {self.maxSize}"

    offsetPtr self.data, occupied

def TemporaryStorage.dealloc(&self, p: &none) =

def TemporaryStorage.reset_to(&self, occupied: SizeT) =
    self.occupied = occupied

    if self.occupied >= self.maxSize then
        context.allocator = context.longterm_storage
        log "ERROR: used more tempory memory than available: {self.occupied}"

type Malloc =

def Malloc.alloc(&self, size: SizeT) &none =
    c_alloc size

def Malloc.dealloc(&self, pointer: &none) =
    c_free pointer

def Malloc.get_occupied(&self) uint =
    0

def Malloc.free_allocator(&self) =

def Malloc.reset_to(&self, to: uint) =



//helper functions
def alloc(size: SizeT) &none =
    context.allocator.alloc size

def indexPtr[T](pType: &T, offset: int) &T =
    (offsetPtr pType, offset * sizeof T) cast &T

def box[T](value: T) &T =
    pointer := (context.allocator.alloc sizeof T) cast &T
    *pointer = value

    pointer

def free(p: &none) =
    context.allocator.dealloc p

def TemporaryStorage.free_allocator(&self) =
    context.longterm_storage.dealloc self.data
