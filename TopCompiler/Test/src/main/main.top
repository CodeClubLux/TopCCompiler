from "html" import (PosAtom,h1,onChange,input,span,p,br,button,app,value,div,style,render,onClick,Event,VNode,mapView,toEffect)
import "http"

/*
type Result[T] either
    Data(T)
    Error

def Result[T].withDefault(self, default: T) T =
    match self with
        Data x -> x
        Error -> default


def Result[A].map[B](self, func: |A| -> B) Result[B] =
    match self with
        Data x -> Data func x
        Error -> Error
*/


def for[A,T,X](func: |A,X| -> (Maybe[T],X), _state: X, arr: []A) []T =
    var state = _state
    var new = [] as []T
    let length = arr.length
    var i = 0

    while i < length do
        let tx = func arr[i], state

        let t = tx.0
        state = tx.1

        new = match t with
            Some tmp -> new.append tmp
            None -> new

        i += 1

    new

let unique = for (|elem: float, indiv: []float|
    if not (indiv.has elem) then
        ((Some elem), indiv.append elem)
    else
        (None, indiv)
), []


ext full sort: |[]float| -> []float = "function(arr)\{
    return fromArray(arr.toArray().sort(function(x,y)\{
        return x > y
    \} ));
\} "

def median(x: []float) float =
    let length = x.length
    let tmp = sort x

    if length % 2 == 0 then
        (tmp[length/2] + tmp[length/2 - 1]) / 2.0
    else
        tmp[(length-1) / 2]

def average(x: []float) float =
    (x.reduce (+)) / toFloat x.length

ext full _console: |Stringable| -> none = "console.log"

def debug[T: Stringable](x: T) T =
    _console x.toString!
    x

def mode(x: []float) string =
    let uniques = (unique x)
    let u = uniques.map |i| ("{i}", (x.filter i==).length,0)
    let count = u
        .reduce |a,b|
            if a.1 > b.1 then a
            elif a.1 == b.1 then ("b",b.1,a.2+1)
            else b

    let _ = debug count.2
    if count.2 == uniques.length-1 then "n" else count.0


def answer(x: []float) VNode =
    div [], [
        h1 [], toString x
        h1 [], "Mean {average x.map toFloat}"
        h1 [], "Median {median x.map toFloat}"
        h1 [], "Mode {mode x}"
    ]

let enter = |x: []float,ev| do
    parse-json decoder []float, "[{ev.target.value}]"

let math = |x: []float, a|
    div [], [
        input [(onChange enter, a), (value x.join ", ")], ""
        answer x
    ]

let app-state = newAtom [0.0]

//let _lens = lens.x
//let pos-a = PosAtom{app-state, _lens}

def test[T: Stringable](func: |T| -> T, x: T) string =
    toString func x

type Point =
    x: int
    y: int

def getPoint(x: Point) Point =
    x

log (dict [
    (0, 10)
    (10, 30)
])[0]

app math, app-state

