import "opengl"
from "glfwWrapper" import all
from "math" import Vec2
from "key" import (Key, KeyAction)

def framebuffer_size_callback(window_ptr: &GLFWwindow, width: int, height: int) =
    context = (glfwGetWindowUserPointer window_ptr) cast &Context

    w := get_window!
    w.width = width cast uint
    w.height = height cast uint

type Window =
    title: string
    vSync: bool
    full_screen: bool
    width: uint
    height: uint

    window_ptr: Maybe[&GLFWwindow]

    cursor_pos_callback: Maybe[|Vec2| -> none]
    key_callback: Maybe[|Key, KeyAction| -> none]
    dropped_filepaths: []string

def error_callback(error: int, description: &char) =
    log char_buffer_toString description

def Window.init(&self) =
    glfwSetErrorCallback error_callback
    glfwInit!
    glfwWindowHint glfw_opengl_forward_compat, opengl.gl_true
    //glfwWindowHint glfw_opengl_profile, glfw_opengl_core_profile
    glfwWindowHint glfw_context_version_major, 4
    glfwWindowHint glfw_context_version_minor, 1

    glfwWindowHint glfw_samples, 4

    log "trying to init window {self.height}, {self.width}, {self.title}"

    c_title := self.title.to_c_string!

    self.window_ptr =
        if self.full_screen then
            monitor := glfwGetPrimaryMonitor!
            glfwCreateWindow self.width, self.height, c_title, monitor, None
        else
            glfwCreateWindow self.width, self.height, c_title, None, None

    guard Some window_ptr := self.window_ptr
    else
        glfwTerminate!
        panic "Failed to create window"

    glfwMakeContextCurrent window_ptr
    glfwSetFramebufferSizeCallback window_ptr, framebuffer_size_callback
    glfwSetCursorPosCallback window_ptr, cursor_pos_callback
    glfwSetKeyCallback window_ptr, key_callback
    glfwSetInputMode window_ptr, glfw_cursor, glfw_cursor_disabled
    glfwSetDropCallback window_ptr, drop_callback

    if not (opengl.gladLoadGLLoader getProcAddress) then
        panic "Failed to initialize GLAD!"

    log "initialized opengl"
    self.update_context!

    if self.vSync then
        glfwSwapInterval 1
    else
        glfwSwapInterval 0

def Window.update_context(&self) =
    glfwSetWindowUserPointer self.window_ptr.unwrap!, context

def Window.capture_mouse(&self, capture: bool) =
    glfwSetInputMode self.window_ptr.unwrap!, glfw_cursor,
        if capture then glfw_cursor_disabled
        else glfw_cursor_normal

def Window.should_close(&self) bool =
    match self.window_ptr with
        Some window_ptr -> glfwWindowShouldClose window_ptr
        None -> true

def Window.update_inputs(&self) =
    self.dropped_filepaths = []
    glfwPollEvents!

def Window.swap_buffers(&self) =
    glfwSwapBuffers self.window_ptr.unwrap!

from "key" import all

//callbacks
def cursor_pos_callback(glfw_window: &GLFWwindow, x: f64, y: f64) =
    context = (glfwGetWindowUserPointer glfw_window) cast &Context
    w := get_window!

    if Some callback := w.cursor_pos_callback then
        callback Vec2{ x cast float, y cast float }

def key_callback(glfwWindow: &GLFWwindow, _key: int, scancode: int, action: int, mods: int) =
    context = (glfwGetWindowUserPointer glfwWindow) cast &Context
    w := get_window!

    if Some callback := w.key_callback then
        if action == glfw_press then
            callback (_key cast Key), Pressed
        elif action == glfw_release then
            callback (_key cast Key), Released

def drop_callback(glfwWindow: &GLFWwindow, count: int, c_paths: &&char) =
    arr := [..]string
    context = (glfwGetWindowUserPointer glfwWindow) cast &Context
    w := get_window!

    for i := 0..(count cast uint) do
        path := char_buffer_toString *(indexPtr c_paths, i)
        buffer := (alloc (path.length + 1) * sizeof char) cast &char
        memcpy buffer, *(indexPtr c_paths, i), (path.length + 1) * sizeof char

        arr.append char_buffer_toString buffer

    w.dropped_filepaths = arr

def Window.set_cursor_pos_callback(&self, func: |Vec2| -> none) =
    self.cursor_pos_callback = Some func

def Window.set_key_callback(&self, func: |Key, KeyAction| -> none) =
    self.key_callback = Some func

def Window.close(&self) =
    match self.window_ptr with
        Some window_ptr ->
            glfwDestroyWindow window_ptr
            glfwTerminate!

        None ->

def Window.key_down(&self, _key: Key) bool =
    (glfwGetKey self.window_ptr.unwrap!, _key) == glfw_press

def Window.mouse_button_down(&self, button: MouseButton) bool =
    glfw_mouse_button := match button with
        Middle -> glfw_mouse_button_middle
        Right -> glfw_mouse_button_right
        Left -> glfw_mouse_button_left

    (glfwGetMouseButton self.window_ptr.unwrap!, glfw_mouse_button) == glfw_press

def make_Window() &Window =
    w := box Window{
        title = "Fernix"
        vSync = true
        full_screen = false
        width = 2000
        height = 1000
        window_ptr = None
        cursor_pos_callback = None
        key_callback = None
        dropped_filepaths = []
    }

    w.init!

    w

#addToContext window := make_Window!

def get_window() &Window =
    context.window
