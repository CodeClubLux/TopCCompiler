type Slot[T] either
    Free(Maybe[&Slot[T]])
    Active(T, ID)

type Pair[A,B] =
    a: A
    b: B

type Store[T] =
    default_with: T
    id_to_obj: [..]Maybe[&T]
    components: []Slot[T]
    free_node: Maybe[&Slot[T]]
    max_number: uint
    init: Maybe[|&T| -> none]

def make_Store_with_init[T](max_number: uint, default: T, init: Maybe[|&T| -> none]) &Store[T] =
    assert max_number > 0, "Minimum number of elements has to be bigger than 0"

    id_to_key := [..]Maybe[&T]
    id_to_key.allocator = Some context.longterm_storage

    slots := [..]Slot[T]
    slots.reserve max_number

    for i := 0..max_number do
        slots.append Free None

    for i := 0..max_number - 1 do
        slots[i] = Free Some &slots[i+1]

    self := box Store{
        default_with = default
        id_to_obj = id_to_key
        free_node = Some &slots[0]
        components = slots
        max_number = max_number
        init = init
    }

    self.deserialize!

    component_types.append self

    self

def make_Store[T](max_number: uint, default: T) &Store[T] =
    make_Store_with_init max_number, default, None as Maybe[|&T| -> none]

entities := make_Store 100, Entity{
    enabled = true
    layermask = make_Layermask!
        .enable game_layer
        .enable serialize_layer
}

def Store[T].get_component_type(&self) Type = get_type T

//get actuall type
def Store[T].by_id(&self, id: ID) Maybe[&T] =
    if id >= self.id_to_obj.length then return None
    self.id_to_obj[id]

//get component
def Store[T].get_by_id(&self, id: ID) Maybe[Component] =
    match self.by_id id with
        Some ptr -> Some ptr cast Component
        None -> None

def Store[T].free_by_id(&self, id: ID) =
    match self.by_id id with
        Some obj_ptr ->
            self.id_to_obj[id] = None
            slot := obj_ptr cast &Slot[T]
            *slot = Free self.free_node
            self.free_node = Some slot

        None ->

//function sets the id_to_obj array which allows components to be indexed by global id
//@cleanup remove all use of dynamic memory allocation

def Store[T].register_component(&self, id: ID, obj_ptr: &T) &T =
    if id >= self.id_to_obj.length then
        self.id_to_obj.reserve id + 1
        for i := self.id_to_obj.length..(id+1) do
            self.id_to_obj.append None

    self.id_to_obj[id] = Some obj_ptr

    obj_ptr

def Store[T].add_component(&self, id: ID, comp: T) &T =
    guard Some free_node := self.free_node
    else panic "Out of memory for system: {get_type T}"

    guard Free next_free_node := *free_node
    else panic "Node that was said to be free is active"

    self.free_node = next_free_node
    *free_node = Active comp, id

    obj_ptr := free_node cast &T //take advantage of the fact that tag is last and since its a union there is enough space for T

    self.register_component id, obj_ptr

def Store[T].make(&self, id: ID) &T =
    self.add_component id, self.default_with

def Store[T].get_all_active(&self) []&T =
    active_components := [..]&T

    for slot := self.components do
        guard Some active_comp := self.index_active i
        else continue

        active_components.append active_comp.a

    active_components

def Store[T].mask_components(&self, layer_mask: Layermask) []&T =
    components := [..]&T

    for slot := self.components do
        guard Some active_comp := self.index_active i
        else continue

        if not active_comp.b.layermask.mask layer_mask then
            components.append active_comp.a

    components

def Store[T].index_active(&self, i: uint) Maybe[Pair[&T, &Entity]] =
    guard Active _, id := self.components[i]
    else return None

    comp := (&self.components[i]) cast &T
    guard Some entity := entities.by_id id
    else return None

    if not entity.enabled then return None

    Some Pair{comp, entity}

def Store[T].get_active(&self) Maybe[&T] =
    for slot := self.components do
        if Some active_comp := self.index_active i then
            return Some active_comp.a

    None

/*
def Store[T].render(&self, layer_mask: Layer) =
    for i := 0..self.components.length do
        guard Some comp := self.index_active i
        else continue

        if not mask comp.b.layermask, layer_mask then
            comp.render!

def Store[T].update(&self, layer_mask: Layermask) =
    for i := 0..self.components.length do
        guard Some comp := self.index_active i
        else continue

        if not mask comp.get_entity!.layermask, layer_mask then
            comp.update!
*/

import "sBuffer"

def Store[T].serialize(&self) =

    new_context := *context
    new_context.allocator = new_context.longterm_storage

    defer new_context.allocator.reset_to new_context.allocator.get_occupied!

    #pushContext new_context do
        serialize_layermask := make_Layermask!
            .enable layermask.serialize_layer

        comps := self.mask_components serialize_layermask

        write_buffer := (sBuffer.make_write_Buffer 10_000_000)
        write_buffer.write_integer comps.length

        log "serializing {get_type T}: {comps.length}"

        for comp := comps do
            write_buffer.write_integer self.id_of comp
            write_buffer.write_object get_type T, comp

        guard Some f := open "assets/save_files/{get_type T}.tsf", WriteBFile
        else panic "Could not write to save_files"

        f.write write_buffer.string_buffer!
        f.free!

def Store[T].id_of(&self, comp: &T) ID =
    guard Active _, id := *(comp cast &Slot[T])
    else panic "Cannot retrieve id: used after free!"

    id

def Store[T].deserialize(&self) =
    //return

    guard Some f := open "assets/save_files/{get_type T}.tsf", ReadBFile
    else panic "Could not read save_files\\{get_type T}"

    defer f.free!
    defer context.allocator.reset_to context.allocator.get_occupied!

    new_context := *context
    new_context.allocator = new_context.longterm_storage

    #pushContext new_context do
        read_buffer := sBuffer.make_read_Buffer f.read!

        num := read_buffer.read_integer!

        log "deserializing {get_type T}: {num}"

        for i := 0..num do
            comp : T = _
            id := read_buffer.read_integer!
            skip_ID id
            read_buffer.read_object get_type T, &comp

            ptr := self.add_component id, comp

            guard Some init := self.init
            else continue

            init ptr

def render(layer_mask: Layermask) =
    for system := systems do
        system.render layer_mask

def update(layer_mask: Layermask) =
    for system := systems do
        system.update layer_mask

def serialize() =
    for i := 0..component_types.length do
        component_types[i].serialize!

def components_by_id(id: ID) [..]Component =
    components := [..]Component

    for system := component_types do
        match system.get_by_id id with
            Some comp -> components.append comp
            _ ->

    components

def register_system(s: System) =
    systems.append s

def filter2[A, B](store_a: &Store[A], store_b: &Store[B], lm: Layermask) [](&A, &B) =
    components_a := store_a.mask_components lm
    zipped := [..](&A, &B)

    for comp := components_a do
        if Some comp2 := store_b.by_id store_a.id_of comp then
            zipped.append (comp, comp2)

    zipped

def filter[A](store: &Store[A], lm: Layermask) []&A =
    store.mask_components lm
