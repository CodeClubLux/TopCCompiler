type Slot[T] either
    Free(Maybe[&Slot[T]])
    Active(T)

type Store[T: Component] =
    make_component_func: |ID| -> &T
    id_to_obj: [..]Maybe[&T]
    components: []Slot[T]
    free_node: Maybe[&Slot[T]]
    max_number: uint
    added: uint

def make_Store[T: Component](make_component: |ID| -> &T, max_number: uint) &Store[T] =
    assert max_number > 0, "Minimum number of elements has to be bigger than 0"

    id_to_key := [..]Maybe[&T]
    id_to_key.allocator = Some context.longterm_storage

    slots := [..]Slot[T]
    slots.reserve max_number

    for i := 0..max_number do
        slots.append Free None

    for i := 0..max_number - 1 do
        slots[i] = Free Some &slots[i+1]

    self := box Store{
        make_component_func = make_component
        id_to_obj = id_to_key
        free_node = Some &slots[0]
        components = slots
        max_number = max_number
        added = 0
    }

    component_types.append self

    self

def Store[T: Component].get_component_type(&self) Type =
    get_type T

def Store[T].make_component(&self, id: ID) =
    _ := self.make_component_func id

//get actuall type
def Store[T].component_by_id(&self, id: ID) Maybe[&T] =
    if id >= self.id_to_obj.length then return None
    self.id_to_obj[id]

//get component
def Store[T].get_component_by_id(&self, id: ID) Maybe[Component] =
    match self.component_by_id id with
        Some ptr -> Some ptr as Component
        None -> None

def Store[T].free_component_by_id(&self, id: ID) =
    match self.component_by_id id with
        Some obj_ptr ->
            self.id_to_obj[id] = None
            slot := obj_ptr cast &Slot[T]
            *slot = Free self.free_node
            self.free_node = Some slot

        None ->

//function sets the id_to_obj array which allows components to be indexed by global id
//@cleanup remove all use of dynamic memory allocation

def Store[T].register_component(&self, id: ID, obj_ptr: &T) &T =
    if id >= self.id_to_obj.length then
        self.id_to_obj.reserve id + 1
        for i := self.id_to_obj.length..(id+1) do
            self.id_to_obj.append None

    self.id_to_obj[id] = Some obj_ptr

    obj_ptr

def Store[T].add_component(&self, comp: T) &T =
    id := (comp.get_entity!).id

    guard Some free_node := self.free_node
    else panic "Out of memory for system: {get_type T}"

    guard Free next_free_node := *free_node
    else panic "Node that was said to be free is active"

    self.free_node = next_free_node
    *free_node = Active comp

    obj_ptr := free_node cast &T //take advantage of the fact that tag is last and since its a union there is enough space for T

    self.added += 1
    self.register_component id, obj_ptr

def Store[T].get_all_active(&self) [..]&T =
    active_components := [..]&T

    for slot := self.components do
        guard Active _ := slot
        else continue

        comp := (&self.components[i]) cast &T
        entity := comp.get_entity!

        if entity.enabled then
            active_components.append comp

    active_components

def Store[T].index_active(&self, i: uint) Maybe[&T] =
    guard Active hey := self.components[i]
    else return None

    comp := (&self.components[i]) cast &T
    if not comp.get_entity!.enabled then return None

    Some comp

def Store[T].get_active(&self) Maybe[&T] =
    for slot := self.components do
        guard Some active_comp := self.index_active i
        else continue

        return Some active_comp

    None

def Store[T].render(&self, layer_mask: Layer) =
    for i := 0..self.components.length do
        guard Some comp := self.index_active i
        else continue

        if not mask comp.get_entity!.layermask, layer_mask then
            comp.render!

def Store[T].update(&self, layer_mask: Layermask) =
    for i := 0..self.components.length do
        guard Some comp := self.index_active i
        else continue

        if not mask comp.get_entity!.layermask, layer_mask then
            comp.update!

def render(layer_mask: Layermask) =
    for i := 0..component_types.length do
        component_types[i].render layer_mask

def update(layer_mask: Layermask) =
    for i := 0..component_types.length do
        component_types[i].update layer_mask

def components_by_id(id: ID) [..]Component =
    components := [..]Component

    for system := component_types do
        match system.get_component_by_id id with
            Some comp -> components.append comp
            _ ->

    components

