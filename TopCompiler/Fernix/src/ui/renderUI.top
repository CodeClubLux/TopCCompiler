import "window"
import "vfs"

def make_ui() &UI =
    let max_vertex_buffer = 512 * 1024
    let max_element_buffer = 128 * 1024

    w := window.get_window!

    nk_ptr := nk_glfw3_init w.window_ptr.unwrap!, nk_glfw3_install_callbacks, max_vertex_buffer, max_element_buffer

    atlas : &nk_font_atlas = _
    nk_glfw3_font_stash_begin &atlas
    segoe := nk_font_atlas_add_from_file atlas, (vfs.asset_path "fonts/segoeui.ttf").to_c_string!, 40, None
    nk_glfw3_font_stash_end!
    nk_style_set_font nk_ptr, &segoe.handle

    box UI{
        nk_ptr = nk_ptr
        windows = [..]&Window
    }

def UI.render(&self) =
    for w := self.windows do
        w.render!

    nk_glfw3_render nk_anti_aliasing_on

def UI.new_frame(&self) =
    self.windows = []
    nk_glfw3_new_frame!

def UI.free(&self) =
    nk_glfw3_shutdown!

ext nk_window_options: uint = "NK_WINDOW_SCALABLE|NK_WINDOW_MINIMIZABLE|NK_WINDOW_TITLE|NK_WINDOW_BORDER"
ext nk_group_options: uint = "NK_WINDOW_TITLE"

type MesgQueue[E] =
    messages: [..]E
    max_messages: uint

def make_MesgQueue[E](max_messages: uint) MesgQueue[E] =
    messages := [..]E
    messages.reserve max_messages

    MesgQueue{
        messages = messages
        max_messages = max_messages
    }

def MesgQueue[E].clear(&self) =
    self.messages.clear!

type Dispatch[E] =
    mesg_queue: &MesgQueue[E]
    only: Event
    mesg: E

def dispatch[E](self: &MesgQueue[E], only: Event, mesg: E) EventHandler =
    box Dispatch{
        mesg_queue = self
        only = only
        mesg = mesg
    }

def Dispatch[E].handle(&self, ev: Event) =
    if ev.tag == self.only.tag then
        assert self.mesg_queue.messages.length != self.mesg_queue.max_messages, "Message qeueu can only handle {self.mesg_queue.max_messages} messages."
        self.mesg_queue.messages.append self.mesg

type Block =
    width: uint
    height: uint
    margin_top_left: Vec2
    margin_bottom_right: Vec2

type Row =
    height: uint
    width: uint
    ratios: [..]float
    elements: [..]&UIElement

def Row.render(&self, width: uint, height: uint) =
    ui := get_ui!

    nk_layout_row ui.nk_ptr, nk_dynamic, self.height, self.ratios.length, self.ratios.data.unwrap!

    for elem := self.elements do
        elem.render (self.width * self.ratios[i]) cast uint, self.height

def Size.calculate(&self, real_size: uint, auto: uint) uint =
    match *self with
        Px x -> math.min x, real_size
        Perc x -> (real_size * x) cast uint
        Auto -> auto

def Size.toString(&self) string =
    match *self with
        Px x -> "Px({x})"
        Perc x -> "Perc({x})"
        Auto -> "Auto"

let default_margin = 5
let default_padding = 15

def Style.calculate_block(&self, owner_block: &Block, container_width: uint, container_height: uint) Block =
    margin_left := self.margin.left.calculate owner_block.width, default_margin
    margin_right := self.margin.right.calculate owner_block.width, default_margin
    margin_top := self.margin.top.calculate owner_block.height, default_margin
    margin_bottom := self.margin.bottom.calculate owner_block.height, default_margin

    padding_left := self.padding.left.calculate owner_block.width, default_padding
    padding_right := self.padding.right.calculate owner_block.width, default_padding
    padding_top := self.padding.top.calculate owner_block.height, default_padding
    padding_bottom := self.padding.bottom.calculate owner_block.height, default_padding

    container_width += padding_right + padding_left
    container_height += padding_top + padding_bottom

    width := self.width.calculate owner_block.width, container_width
    height := self.height.calculate owner_block.height, container_height

    Block{
        width = width
        height = height
        margin_top_left = Vec2{ margin_left, margin_top }
        margin_bottom_right = Vec2{ margin_right, margin_bottom }
    }

let assumed_font_width = 15

def calculate_text_width(text: string, style: &Style) uint =
    text.length * assumed_font_width

def calculate_text_height(style: &Style) uint =
    15

default_row := Row{
    height = 0
    width = 0
    ratios = []
    elements = []
}

let default_property_width = 15 * 20 //100
let default_input_width = 15 * 20

def calculate_layout(rows: &[..]Row, owner_block: &Block, element: &UIElement) =
    current_row :=
        if rows.length == 0 then
            rows.append default_row
            &rows[0]
        else
            &rows[rows.length - 1]

    newline := false
    block := match *element with
        Element_Label l -> l.style.calculate_block owner_block, (calculate_text_width l.text, &l.style), (calculate_text_height &l.style)
        Element_Button l -> l.style.calculate_block owner_block, (calculate_text_width l.text, &l.style), (calculate_text_height &l.style)
        Element_Propertyf l -> l.style.calculate_block owner_block, default_property_width, (calculate_text_height &l.style)
        Element_Input l -> l.style.calculate_block owner_block, default_input_width, (calculate_text_height &l.style)
        Element_NewLine ->
            newline = true
            Block{ 0, 0, Vec2{0,0}, Vec2{0,0}}

        Element_Group g ->
            group_width := 0
            group_height := 0

            g_rows := [..]Row

            for child := g.children do
                calculate_layout &g_rows, owner_block, &g.children[i]

            for row := g_rows do
                group_width += row.width
                group_height += row.height + default_margin

            g.style.calculate_block owner_block, group_width, group_height

    if newline then
        rows.append default_row
        return

    if current_row.width + block.width > owner_block.width then
        rows.append default_row
        current_row = &rows[rows.length - 1]

    current_row.width += block.width
    current_row.ratios.append block.width / owner_block.width
    current_row.elements.append element
    current_row.height = math.max block.height, current_row.height

def UIElement.render(&self, width: uint, height: uint) =
    match *self with
        Element_Label l -> l.render!
        Element_Button l -> l.render!
        Element_Propertyf l -> l.render!
        Element_Input l -> l.render!
        Element_NewLine ->
        Element_Group g ->
            ui := get_ui!
            if nk_group_begin ui.nk_ptr, g.title.to_c_string!, nk_group_options then
                g.style.width = Px width
                g.style.height = Px height

                empty_block := Block{ width, height, Vec2{0,0}, Vec2{0,0}}

                block: Block = _
                rows := g.calculate_layout &empty_block, width, height, &block

                for row := rows do
                    row.render block.width, block.height

                nk_group_end ui.nk_ptr

import "window"



def Window.calculate_layout(&self, window_block: &Block, default_width: uint, default_height: uint, block: &Block) []Row =
    rows := [..]Row

    *block = self.style.calculate_block window_block, default_width, default_height

    for child := self.children do
        calculate_layout &rows, block, &self.children[i]

    rows

def Window.render(&self) =
    w := window.get_window!

    window_block := Block{
        width = w.width cast uint
        height = w.height cast uint
        margin_top_left = Vec2{0,0}
        margin_bottom_right = Vec2{0,0}
    }

    block : Block = _

    //layouting
    rows := self.calculate_layout &window_block, 100, 100, &block

    if self.begin Vec2{ block.width, block.height} then
        //rendering
        for row := rows do
            row.render row.width, row.height

    //destroy window
    self.end!

def Label.render(&options) =
    ui := get_ui!
    nk_label ui.nk_ptr, options.text.to_c_string!, nk_text_left

def Button.render(&options) =
    ui := get_ui!
    selected := options.selected cast int

    if nk_selectable_label ui.nk_ptr, options.text.to_c_string!, nk_text_left, &selected then
        guard Some ev_handler := options.ev_handler
        else return

        ev_handler.handle Pressed

def Propertyf.render(&options) =
    ui := get_ui!

    field_with_id := "#{options.text}"
    *options.value = nk_propertyf ui.nk_ptr, field_with_id.to_c_string!, options.min, *options.value, options.max, options.step, options.inc_per_pixel

/*
def group_begin(options: GroupOptions) bool =
    ui := get_ui!

    nk_group_begin ui.nk_ptr, options.title.to_c_string!, nk_group_options

def group_end() =
    ui := get_ui!
    nk_group_end ui.nk_ptr
*/

def Input.render(&options) =
    ui := get_ui!
    buffer := options.buffer
    nk_edit_string_zero_terminated ui.nk_ptr, nk_edit_simple, buffer, options.max_length, None
    //*options.value = char_buffer_toString buffer

def Window.begin(&self, size: Vec2) bool =
    ui := get_ui!

    position := match self.position with
        Absolute x, y -> Vec2{ x, y }
        Relative -> Vec2{0, 0}

    c_title := self.title.to_c_string!
    window_rect := nk_make_rect position.x, position.y, size.x, size.y

    nk_begin ui.nk_ptr, c_title, window_rect, nk_window_options

def Window.end(&self) =
    nk_end get_ui!.nk_ptr
