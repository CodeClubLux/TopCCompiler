type Quat =
    x: float
    y: float
    z: float
    w: float

def identity_quat() Quat =
    Quat{ 0, 0, 0, 1 }

def Quat.op_add(&self, other: &Quat) Quat =
    Quat{
        self.x + other.x
        self.y + other.y
        self.z + other.z
        self.w + other.w
    }

def Quat.op_sub(&self, other: &Quat) Quat =
    Quat{
        self.x - other.x
        self.y - other.y
        self.z - other.z
        self.w - other.w
    }

def Quat.scale(&self, s: float) =
    Quat{
        self.x * s
        self.y * s
        self.z * s
        self.w * s
    }

def Quat.norm(s) Quat =
    n := sqrt s.x*s.x + s.y*s.y + s.z*s.z + s.w*s.w
    Quat{
        s.x/n
        s.y/n
        s.z/n
        s.w/n
    }

def Quat.inner_product(&a, b: &Quat) float =
    b.x * a.x + b.y * a.y + b.z * a.y + b.w * a.w

def make_quat(angle: float, axis: Vec3) Quat =
    v := axis.scale sin angle / 2

    Quat{
        x = v.x
        y = v.y
        z = v.z
        w = cos angle / 2
    }

def Quat.op_mul(a, b: Quat) Quat =
    Quat{
        w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z
        x = a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y
        y = a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x
        z = a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w
    }

def Quat.unary_sub(quaternion) Quat =
    num2 := (((quaternion.x * quaternion.x) + (quaternion.y * quaternion.z)) + (quaternion.z * quaternion.z)) + (quaternion.w * quaternion.w)
    num := 1.0 / num2

    Quat{
        x = -quaternion.x * num
        y = -quaternion.y * num
        z = -quaternion.z * num
        w = quaternion.w * num
    }

def Quat.mul_vec3(&q, v: Vec3) Vec3 =
    u := Vec3{q.x, q.y, q.z}
    s := q.w

    a := u.scale 2*(u.dot v)
    b := v.scale (s*s - (u.dot u))
    c := (u.cross v).scale 2*s

    a + b + c

def Quat.toString(&self) string =
    "Quat({self.w}, {self.x}, {self.y}, {self.z})"

def Quat.to_vec3(&rotation) Vec3 =
    x := Vec3{1,0,0}
    y := Vec3{0,1,0}
    z := Vec3{0,0,1}

    rot_x := rotation.mul_vec3 x
    rot_y := rotation.mul_vec3 y
    rot_z := rotation.mul_vec3 z

    vec := Vec3{rot_x.x * 180 - 180, rot_y.y * 180 - 180, rot_z.z * 180 - 180}
    if vec.x > 360 then vec.x -= 360
    elif vec.x < (-360) then vec.x += 360
    
    if vec.y > 360 then vec.y -= 360
    elif vec.y < (-360) then vec.y += 360
    
    if vec.z > 360 then vec.z -= 360
    elif vec.z < (-360) then vec.z += 360

    vec

q1 := make_quat (radians 90), Vec3{0,0,1}
v2 := Vec3{1,0,0}
v2 = q1.mul_vec3 v2

/*
log v2.x
log v2.y
log v2.z
log "==== quat "
*/
//vec := tmp2.mul_vec3 Vec3{0,0,-1}

//def Quat.op_sub(&self, other: &Quat) Quat =

