import "ecs"
import "shader"
import "buffer"
import "model"
import "input"
import "camera"
from "materialSystem" import (Material, Param_Vec3)
from "math" import all
import "key"
import "editor"
import "draw"
from "transform" import all

gizmo_shader := shader.make "shaders/gizmo.vert", "shaders/gizmo.frag"

draw_over := draw.default_state{
    clear_depth_buffer = true
    order = draw.draw_last
}

translation_model_materials := [
    materialSystem.Material{
        name = "Up"
        shader = gizmo_shader
        params = box [
            Param_Vec3 "color", Vec3{ 1, 0, 0}
        ]
        state = &draw_over
    }
    materialSystem.Material{
        name = "Right"
        shader = gizmo_shader
        params = box [
            Param_Vec3 "color", Vec3{ 0, 1, 0}
        ]
        state = &draw_over
    }
    materialSystem.Material{
        name = "Forward"
        shader = gizmo_shader
        params = box [
            Param_Vec3 "color", Vec3{ 0, 0, 1}
        ]
        state = &draw_over
    }
]

translation_model := model.load_model "gizmo.fbx"
scale_model := model.load_model "scale_gizmo.fbx"

type Axis either
    Up(Vec3)
    Right(Vec3)
    Forward(Vec3)
    NoAxis

def Axis.toString(&self) string =
    match *self with
        Up v -> "Up: {v}"
        Right v -> "Right: {v}"
        Forward v -> "Forward: {v}"
        NoAxis -> "No Axis"

type GizmoType either
    Translate(Axis)
    Scale(Axis)
    Disabled

type Gizmo =
    entity: &ecs.Entity
    model_renderer: &model.ModelRenderer
    kind: GizmoType

def Gizmo.get_entity(&self) &ecs.Entity =
    self.entity

def Gizmo.render(&self) =

type Ray =
    origin: Vec3
    direction: Vec3
    t: float

//constants
let flt_min = 0.001
let flt_max = 10000.0

type Closest_Point_Result =
    distance: float
    closest_point_1: Vec3
    closest_point_2: Vec3

def Closest_Point_Result.toString(using &self) string =
    "distance: {distance}, closest_point_1: {closest_point_1}, closest_point_2: {closest_point_2}"

def closest_point(r1: &Ray, r2: &Ray) Maybe[Closest_Point_Result] =
    line_point1 := r1.origin
    line_point2 := r2.origin

    line_vec1 := r1.direction
    line_vec2 := r2.direction

    a := line_vec1.dot line_vec1
    b := line_vec1.dot line_vec2
    e := line_vec2.dot line_vec2

    d := a*e - b*b

    if (abs d) > flt_min then
        r := line_point1 - line_point2
        c := line_vec1.dot r
        f := line_vec2.dot r

        s := (b*f - c*e) / d
        t := (a*f - c*b) / d

        closest_point1 := line_point1 + line_vec1.scale (max 0.0, (min r1.t, s))
        closest_point2 := line_point2 + line_vec2.scale (max 0.0, (min r2.t, t))

        Some Closest_Point_Result{
            distance = (closest_point2 - closest_point1).len!
            closest_point_1 = line_point1 + line_vec1.scale s
            closest_point_2 = line_point2 + line_vec2.scale t
        }
    else
        None


def handle_gizmo_intersection(position: Vec3, axis: Axis, gizmo_scale: Vec3, vector: &Vec3, reverse_z: bool) Axis =
    greatest_distance := 0.15 * gizmo_scale.x
    inp := input.get_input!
    cam := camera.get_camera!

    if not inp.mouse_button_down key.Left then
        translation_model_materials[0].params[0] = Param_Vec3 "color", Vec3{1,0,0}
        translation_model_materials[1].params[0] = Param_Vec3 "color", Vec3{0,1,0}
        translation_model_materials[2].params[0] = Param_Vec3 "color", Vec3{0,0,1}
        return NoAxis

    right_ray := Ray{
        origin = position
        direction = Vec3{1,0,0}
        t = gizmo_scale.x
    }

    up_ray := Ray{
        origin = position
        direction = Vec3{0,1,0}
        t = gizmo_scale.y
    }

    forward_ray := Ray{
        origin = position
        direction = Vec3{0,0,-1}
        t = gizmo_scale.z
    }

    n := inp.to_device_coord inp.mouse_position

    view_proj_inverse := invert (cam.projection_matrix * cam.view_matrix)

    ray_start := (&view_proj_inverse).mul_vec4 Vec4{n.x, n.y, 0, 1}
    ray_start = ray_start.scale (1.0 / ray_start.w)

    ray_end := (&view_proj_inverse).mul_vec4 Vec4{n.x, n.y, 1, 1.0}
    ray_end = ray_end.scale (1.0 / ray_end.w)

    ray_start_vec3 := Vec3{ray_start.x, ray_start.y, ray_start.z}
    ray_end_vec3 := Vec3{ray_end.x, ray_end.y, ray_end.z}

    view_ray := Ray{
        origin = ray_start_vec3
        direction = (ray_end_vec3 - ray_start_vec3).norm!
        t = flt_max
    }

    failed_intersect := Closest_Point_Result{
        distance = 1000
        closest_point_1 = Vec3{0,0,0}
        closest_point_2 = Vec3{0,0,0}
    }

    //test for intersection
    i_right := (closest_point &right_ray, &view_ray).default failed_intersect
    i_up := (closest_point &up_ray, &view_ray).default failed_intersect
    i_forward := (closest_point &forward_ray, &view_ray).default failed_intersect

    d1 := i_right.distance
    d2 := i_up.distance
    d3 := i_forward.distance

    match axis with
        //select axis
        NoAxis ->
            if d1 < d2 and d1 < d3 and d1 < greatest_distance then
                translation_model_materials[2].params[0] = Param_Vec3 "color", Vec3{1,1,0}
                Right i_right.closest_point_1

            elif d2 < d1 and d2 < d3 and d2 < greatest_distance then
                translation_model_materials[1].params[0] = Param_Vec3 "color", Vec3{1,1,0}
                Up i_up.closest_point_1

            elif d3 < greatest_distance then
                translation_model_materials[0].params[0] = Param_Vec3 "color", Vec3{1,1,0}
                Forward i_forward.closest_point_1

            else NoAxis

        //move gizmo
        Right last_intersection ->
            *vector += (i_right.closest_point_1 - last_intersection)
            Right i_right.closest_point_1

        Up last_intersection ->
            *vector += (i_up.closest_point_1 - last_intersection)
            Up i_up.closest_point_1

        Forward last_intersection ->
            if reverse_z then
                *vector -= (i_forward.closest_point_1 - last_intersection)
            else
                *vector += (i_forward.closest_point_1 - last_intersection)
            Forward i_forward.closest_point_1

let size_of_gizmo = 0.1

def scale_of_gizmo(diff: Vec3) float =
    size_of_gizmo * diff.len!

def Gizmo.update(&self) =
    inp := input.get_input!
    model_renderer := self.model_renderer
    cam := camera.get_camera!

    if inp.key_down key.from_char `T` then
        self.kind = Translate NoAxis
    elif inp.key_down key.from_char `E` then
        self.kind = Scale NoAxis
    elif inp.key_down key.esc then
        self.kind = Disabled

    model_renderer.visible = false

    guard Some target_id := editor.editor.selected
    else return

    guard Some target := transform_system.component_by_id target_id
    else return

    if not target.get_entity!.enabled then return

    model_renderer_entity := model_renderer.transform
    model_renderer_entity.position = target.position
    model_renderer.visible = true

    s := model_renderer_entity.scale
    s_multiplier := Vec3{1,1,1}

    match self.kind with
        Translate axis ->
            self.kind = Translate handle_gizmo_intersection target.position, axis, s, &target.position, false
            model_renderer.model_id = Some ecs.get_id_for translation_model
            model_renderer.set_materials &translation_model_materials
            model_renderer_entity.position = target.position

        Scale axis ->
            self.kind = Scale handle_gizmo_intersection target.position, axis, s, &target.scale, true
            model_renderer.model_id = Some ecs.get_id_for scale_model
            model_renderer.set_materials &translation_model_materials

        Disabled ->
            model_renderer.model_id = None

    model_renderer_entity.scale = s_multiplier.scale scale_of_gizmo (cam.transform.position - model_renderer_entity.position)

import "layermask"

gizmo_system := ecs.make_Store make_Gizmo, 1
_ := make_Gizmo ecs.make_ID!

def make_Gizmo(id: ecs.ID) &Gizmo =
    entity := match ecs.entity_system.component_by_id id with
        Some e -> e
        None ->
            entity := ecs.make_Entity id
            entity.layermask = layermask.enable layermask.make_Layermask!, layermask.editor_layer
            entity

    model_renderer := match model.model_renderer_system.component_by_id id with
        Some m -> m
        None -> model.make_ModelRenderer id

    gizmo_system.add_component Gizmo{
        entity = entity
        kind = Disabled
        model_renderer = model_renderer
    }
