import "ecs"
import "shader"
import "buffer"
import "model"
import "input"
import "camera"
from "materialSystem" import (Material, Param_Vec3)
from "math" import all
import "key"

gizmo_shader := shader.make "assets/shaders/gizmo.vert", "assets/shaders/gizmo.frag"

translation_model_materials := [
    materialSystem.Material{
        name = "Up"
        shader = gizmo_shader
        params = box [
            Param_Vec3 "color", Vec3{ 1, 0, 0}
        ]
    }
    materialSystem.Material{
        name = "Right"
        shader = gizmo_shader
        params = box [
            Param_Vec3 "color", Vec3{ 0, 1, 0}
        ]
    }
    materialSystem.Material{
        name = "Forward"
        shader = gizmo_shader
        params = box [
            Param_Vec3 "color", Vec3{ 0, 0, 1}
        ]
    }
]

translation_model := model.load_model "assets/gizmo.fbx", &translation_model_materials

type GizmoType either
    Translate
    Disabled

type Gizmo =
    entity: &ecs.Entity
    model_renderer: &model.ModelRenderer
    target: Maybe[ecs.ID]
    kind: GizmoType

def Gizmo.get_entity(&self) &ecs.Entity =
    self.entity

def Gizmo.set_target(&self, entity: ecs.ID) =
    self.target = Some entity

def Gizmo.render(&self) =

/*
def Gizmo.is_active(&self) =
    target_id := match self.target with
        Some x -> x
        None -> return false

    target := match ecs.entity_system.component_by_id target_id with
        Some x -> x
        None -> return false

    if not target.enabled then return false

    match target with
        Translate -> self.handle_translation target
        Disabled -> false
*/

type Ray =
    origin: Vec3
    direction: Vec3
    t: float

let flt_min = 0.001
let flt_max = 100


def closest_distance_between_lines(l1: &Ray, l2: &Ray) float =
    dp := l2.origin - l1.origin
    v12 := l1.direction.dot l1.direction
    v22 := l2.direction.dot l2.direction
    v1v2 := l1.direction.dot l2.direction

    det := v1v2 * v1v2 - v12 * v22

    if (abs det) > flt_min then
        inv_det := 1.0 / det

        dpv1 := dp.dot l1.direction
        dpv2 := dp.dot l2.direction

        l1.t = inv_det * (v22 * dpv1 - v1v2 * dpv2)
        l2.t = inv_det * (v1v2 * dpv1 - v12 * dpv2)

        (dp + (l2.direction.scale l2.t) - (l1.direction.scale l1.t)).len!
    else
        a := dp.cross l1.direction
        sqrt (a.dot a) / v12

def Gizmo.handle_translation(&self, target: &ecs.Entity) bool =
    inp := input.get_input!
    cam := camera.get_camera!

    if not inp.mouse_button_down key.Left then return true

    n := inp.to_device_coord inp.mouse_position

    view_proj_inverse := invert (cam.projection_matrix * cam.view_matrix)

    ray_start := (&view_proj_inverse).mul_vec4 Vec4{n.x, n.y, 0, 1}
    ray_start = ray_start.scale (1.0 / ray_start.w)

    ray_end := (&view_proj_inverse).mul_vec4 Vec4{n.x, n.y, 1, 1.0}
    ray_end = ray_end.scale (1.0 / ray_end.w)

    ray_start_vec3 := Vec3{ray_start.x, ray_start.y, ray_start.z}
    ray_end_vec3 := Vec3{ray_end.x, ray_end.y, ray_end.z}

    r := Ray{
        origin = ray_start_vec3
        direction = (ray_end_vec3 - ray_start_vec3).norm!
        t = flt_max
    }

    t1 := Ray{
        origin = target.position
        direction = Vec3{1,0,0}
        t = 1.0
    }

    t2 := Ray{
        origin = target.position
        direction = Vec3{0,1,0}
        t = 1.0
    }

    t3 := Ray{
        origin = target.position
        direction = Vec3{0,0,-1}
        t = 1.0
    }

    d1 := closest_distance_between_lines &t1, &r
    d2 := closest_distance_between_lines &t2, &r
    d3 := closest_distance_between_lines &t3, &r

    log "===="
    log "origin: {r.origin}, direction: {r.direction}, cam_position: {cam.get_entity!.position}"

    if d1 < d2 and d1 < d3 then
        log "right"
    elif d2 < d1 and d2 < d3 then
        log "up"
    else
        log "forward"

    true

def Gizmo.update(&self) =
    inp := input.get_input!
    model_renderer := self.model_renderer

    if inp.key_down key.from_char `G` then
        self.kind = Translate
    if inp.key_down key.esc then
        self.kind = Disabled

    model_renderer.visible = match self.target with
        Some target_id ->
            match ecs.entity_system.component_by_id target_id with
                Some target ->
                    if target.enabled then
                        match self.kind with
                            Translate -> self.handle_translation target
                            Disabled -> false
                    else false
                None ->
                    self.target = None //Object was destroyed
                    false

        None -> false //No object is selected

import "layermask"

def make_GizmoSystem() &ecs.Store[Gizmo] =
    system := ecs.make_Store::[Gizmo] 1

    entity := ecs.make_Entity!
    entity.layermask = layermask.enable layermask.make_Layermask!, layermask.editor

    model_renderer := model.make_ModelRenderer entity, &translation_model

    _ := system.add_component Gizmo{
        entity = entity
        target = None
        kind = Disabled
        model_renderer = model_renderer
    }

    system

gizmo_system := make_GizmoSystem!